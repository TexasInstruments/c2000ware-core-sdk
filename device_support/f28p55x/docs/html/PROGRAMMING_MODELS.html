<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>f28p55x Driverib and Example User Guide: Programming Models</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="f28p55x Driverib and Example User Guide"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">f28p55x Driverib and Example User Guide
   &#160;<span id="projectnumber">6.00.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('PROGRAMMING_MODELS.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Programming Models </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1">Direct Register Access Model</a></li>
<li class="level1"><a href="#autotoc_md2">Software Driver Model</a></li>
<li class="level1"><a href="#autotoc_md3">Combining The Models</a></li>
<li class="level1"><a href="#autotoc_md4">Documentation Credits</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_siddharth_ti_repos_c29_sdk_docs_docs_src_docs_api_guide_device_common_c28x_programming_models"></a></p>
<p>The peripheral driver library provides support for two programming models: the direct register access model and the software driver model. Each model can be used independently or combined, based on the needs of the application or the programming environment desired by the developer.</p>
<p>Each programming model has advantages and disadvantages. Use of the direct register access model generally results in smaller and more efficient code than using the software driver model. However, the direct register access model requires detailed knowledge of the operation of each register and bit field, as well as their interactions and any sequencing required for proper operation of the peripheral; the developer is somewhat more insulated from these details by the software driver model, generally requiring less time to develop applications. The software driver model also results in more readable code.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Direct Register Access Model</h1>
<p>In the direct register access model, the peripherals are programmed by the application by writing values directly into the peripheral's registers. A set of macros is provided that simplifies this process. These macros are stored in several header files contained in the inc directory. By including the header files inc/hw_types.h and inc/hw_memmap.h, macros are available for accessing all registers. Individual bitfield accesses can easily be added by simply including the inc/hw_peripheral.h header file for the desired peripheral.</p>
<p>The defines used by the direct register access model follow a naming convention that makes it easier to know how to use a particular macro. The rules are as follows:</p>
<ul>
<li>Values that end in _BASE and are found in inc/hw_memmap.h are module instance base addresses. For example, SPIA_BASE and SPIB_BASE are the base addresses of instances A and B of the SPI module respectively.</li>
<li>Values that contain an <em>O</em> are register address offsets used to access the value of a register. For example, SPI_O_CCR is used to access the CCR register in a SPI module. These can be added to the base address values to get the register address.</li>
<li>Values that end in _M represent the mask for a multi-bit field in a register. For example, SPI_CCR_SPICHAR_M is a mask for the SPICHAR field in the CCR register. Note that fields that are the whole width of the register are not given masks.</li>
<li>Values that end in _S represent the number of bits to shift a value in order to align it with a multi-bit field. These values match the macro with the same base name but ending with _M.</li>
<li>All others are single-bit field masks. For example, SPI_CCR_SPILBK corresponds to the SPILBK bit in the CCR register.</li>
</ul>
<p>The inc\hw_types.h file contains macros to access a register. They are as follows where x is the address to be accessed:</p>
<ul>
<li>HWREG(x) is used for 32-bit accesses, such as reading a value from a 32-bit counter register.</li>
<li>HWREGH(x) is used for 16-bit accesses. This can be used to access a 16-bit register or the upper or lower words of a 32-bit register. This is usually the most efficient.</li>
<li>HWREGB(x) is used for 8-bit accesses using the __byte() intrinsic (see the TMS320C28x Optimizing C/C++ Compiler User's Guide). It typically should only be used when an 8-bit access is required by the hardware. Otherwise, use HWREGH() and mask and shift out the unwanted bits.</li>
<li>HWREG_BP(x) is another macro used for 32-bit accesses, but it uses the __byte_peripheral_32() compiler intrinsic. This is intended for use with peripherals that use a special addressing scheme to support byte accesses such as CAN or USB.</li>
</ul>
<p>Given these definitions, the CCR register can be programmed as follows:</p>
<p>// Enable loopback mode on SPI A HWREGH(SPIA_BASE + SPI_O_CCR) |= SPI_CCR_SPILBK;</p>
<p>// Change the number of bits that make up a character to 8 // * First clear the field // * Then shift the new value into place and write it into the register HWREGH(SPIA_BASE + SPI_O_CCR) &amp;= ~SPI_CCR_SPICHAR_M; HWREGH(SPIA_BASE + SPI_O_CCR) |= 8 &lt;&lt; SPI_CCR_SPICHAR_S;</p>
<p>Extracting the value of the SPICHAR field in the CCR register is as follows: </p><pre class="fragment">x = (HWREGH(SPIA_BASE + SPI_O_CCR) &amp; SPI_CCR_SPICHAR_M) &gt;&gt; SPI_CCR_SPICHAR_S;
</pre> <h1><a class="anchor" id="autotoc_md2"></a>
Software Driver Model</h1>
<p>In the software driver model, the API provided by the peripheral driver library is used by applications to control the peripherals. Because these drivers provide complete control of the peripherals in their normal mode of operation, it is possible to write an entire application without direct access to the hardware. This method provides for rapid development of the application without requiring detailed knowledge of the registers.</p>
<p>The following function call programs the SPICHAR field of CCR register mentioned in the direct register access model as well as a few other fields and registers. </p><pre class="fragment">SPI_setConfig(SPIA_BASE, 100000000, SPI_PROT_POL0PHA0,SPI_MODE_MASTER, 500000, 16);
</pre><p> The drivers in the peripheral driver library are described in the remaining chapters in this document. They combine to form the software driver model.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Combining The Models</h1>
<p>The direct register access model and software driver model can be used together in a single application, allowing the most appropriate model to be applied as needed to any particular situation within the application. For example, the software driver model can be used to configure the peripherals (because this is not performance critical) and the direct register access model can be used for operation of the peripheral (which may be more performance critical). Or, the software driver model can be used for peripherals that are not performance critical (such as SCI used for data logging) and the direct register access model for performance critical peripherals.</p>
<p>Additionally, the direct register access model can be used when there is no suitable driver library API for the desired task. Although an API may be available that performs a specific function on an individual bit or register, it could be more beneficial to use the direct register access programming model when performing tasks on entire registers or multiple bits at a given time. However, if there is an API available for the intended task it should be used as it will provide for more rapid development of the application without going into depth on programming the peripherals.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Documentation Credits</h1>
<p>This user guide is generated using doxygen, v1.8.20. See <a href="https://www.doxygen.nl/index.html">https://www.doxygen.nl/index.html</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
