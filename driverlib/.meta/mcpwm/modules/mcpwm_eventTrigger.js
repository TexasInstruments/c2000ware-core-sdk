let Common   = system.getScript("/driverlib/Common.js");
let Pinmux   = system.getScript("/driverlib/pinmux.js");
let device_driverlib_peripheral = 
    system.getScript("/driverlib/device_driverlib_peripherals/" + 
        Common.getDeviceName().toLowerCase() + "_mcpwm.js");

var ADC_SOC_configs = []

function onChangeInterrupt (inst, ui)
{
    if (inst.mcpwmEventTrigger_enableInterrupt)
    {
       ui.mcpwmEventTrigger_registerInterrupts.hidden = !inst.mcpwmEventTrigger_enableInterrupt
       ui.mcpwmEventTrigger_interruptSource.hidden = !inst.mcpwmEventTrigger_enableInterrupt
    }
    else if (inst.mcpwmEventTrigger_enableInterrupt == false){
        // Set values to their defaults
        inst.mcpwmEventTrigger_registerInterrupts = false;
        inst.mcpwmEventTrigger_interruptSource =  [];
    }
}

function onChangeADCEnableDisable(inst, ui)
{
    for (var soc of device_driverlib_peripheral.MCPWM_ADCStartOfConversionType){
        ui["mcpwmEventTrigger_" + soc.name + "_triggerSource"].hidden = !inst["mcpwmEventTrigger_" + soc.name + "_triggerEnable"]
        ui["mcpwmEventTrigger_" + soc.name + "_triggerEventPrescalar"].hidden = !inst["mcpwmEventTrigger_" + soc.name + "_triggerEnable"]
        
        // set to defaults
        if(!inst["mcpwmEventTrigger_" + soc.name + "_triggerEnable"]){
            inst["mcpwmEventTrigger_" + soc.name + "_triggerSource"] = device_driverlib_peripheral.MCPWM_ADCStartOfConversionSource[0].name
            inst["mcpwmEventTrigger_" + soc.name + "_triggerEventPrescalar"] = mcpwmCount[0].name
        }
    }
}
function onChangeETEnableDisable(inst, ui)
{
    for (var soc of device_driverlib_peripheral.MCPWM_EventTriggerType){
        ui["mcpwmEventTrigger_" + soc.name + "_triggerSource"].hidden = !inst["mcpwmEventTrigger_" + soc.name + "_triggerEnable"]
        ui["mcpwmEventTrigger_" + soc.name + "_triggerEventPrescalar"].hidden = !inst["mcpwmEventTrigger_" + soc.name + "_triggerEnable"]
        
        // set to defaults
        if(!inst["mcpwmEventTrigger_" + soc.name + "_triggerEnable"]){
            inst["mcpwmEventTrigger_" + soc.name + "_triggerSource"] = device_driverlib_peripheral.MCPWM_EventTriggerSource[0].name
            inst["mcpwmEventTrigger_" + soc.name + "_triggerEventPrescalar"] = mcpwmCount[0].name
        }
    }
}


var mcpwmCount = [
    { displayName: "Disabled", name: "0" }, 
    { displayName: "1 Event Generates Interrupt", name: "1" }, 
    { displayName: "2 Events Generates Interrupt", name: "2" },
    { displayName: "3 Events Generates Interrupt", name: "3" },
    { displayName: "4 Events Generates Interrupt", name: "4" },
    { displayName: "5 Events Generates Interrupt", name: "5" },
    { displayName: "6 Events Generates Interrupt", name: "6" },
    { displayName: "7 Events Generates Interrupt", name: "7" },
]

/* Array of CAN configurables that are common across device families */
var config = [
    {
        name: "mcpwmEventTrigger_enableInterrupt",
        displayName : "Enable MCPWM Interrupt",
        description : 'Check to enable MCPWM interrupt',
        hidden      : false,
        default     : false,
        onChange    : onChangeInterrupt 
    },
    {
        name        : "mcpwmEventTrigger_registerInterrupts",
        displayName : "Register Interrupt Handler",
        description : 'Whether or not to register interrupt handlers in the interrupt module.',
        hidden      : true,
        default     : false
        
    },
    {
        name: "mcpwmEventTrigger_interruptSource",
        displayName : "Interrupt Event Sources",
        description : 'Select all events that must be enabled to generate an MCPWM interrupt',
        hidden      : true,
        minSelections : 0,
        default     : [],
        options     : ()=>{
            let opt = []
            for (let option of device_driverlib_peripheral.MCPWM_INT){
                if (! option.name.includes("_ALL")){
                    opt.push(option)
                }
            }
            return opt
            
        }
    },
];

let ET_configs = []
for ( let et of device_driverlib_peripheral.MCPWM_EventTriggerType){
    var et_name = "ET" + et.name.replace("MCPWM_ET_", "");
    ET_configs = ET_configs.concat([
        {
            name: "mcpwmEventTrigger_" + et.name + "_triggerEnable",
            displayName : et_name + " Trigger Enable",
            description : 'Enable the Event generated by the ET ' + et_name,
            hidden      : false,
            default     : false,
            onChange    : onChangeETEnableDisable
        },
        { 
            name: "mcpwmEventTrigger_" + et.name + "_triggerSource", 
            displayName : et_name + " Trigger Source",
            description : 'Select the SOC trigger source for ' + et_name,
            hidden      : true,
            default     : device_driverlib_peripheral.MCPWM_EventTriggerSource[0].name,
            options     : device_driverlib_peripheral.MCPWM_EventTriggerSource
        },
        {
            name: "mcpwmEventTrigger_" + et.name + "_triggerEventPrescalar",
            displayName : et_name + " Trigger Event Count",
            description : 'The number of events that have to occur before an SOC is issued',
            hidden      : true,
            default     : mcpwmCount[0].name,
            options     : mcpwmCount
        },
    ])
}


for (var socIndex in device_driverlib_peripheral.MCPWM_ADCStartOfConversionType)
{
    var soc = device_driverlib_peripheral.MCPWM_ADCStartOfConversionType[socIndex];
    var soc_name = "SOC" + soc.name.replace("MCPWM_SOC_", "");
    ADC_SOC_configs = ADC_SOC_configs.concat([
        {
            name: "mcpwmEventTrigger_" + soc.name + "_triggerEnable",
            displayName : soc_name + " Trigger Enable",
            description : 'Enable the SOC trigger generated by the ET submodule for ' + soc_name,
            hidden      : false,
            default     : false,
            onChange    : onChangeADCEnableDisable
        },
        { 
            name: "mcpwmEventTrigger_" + soc.name + "_triggerSource", 
            displayName : soc_name + " Trigger Source",
            description : 'Select the SOC trigger source for ' + soc_name,
            hidden      : true,
            default     : device_driverlib_peripheral.MCPWM_ADCStartOfConversionSource[0].name,
            options     : device_driverlib_peripheral.MCPWM_ADCStartOfConversionSource
        },
        {
            name: "mcpwmEventTrigger_" + soc.name + "_triggerEventPrescalar",
            displayName : soc_name + " Trigger Event Count",
            description : 'The number of events that have to occur before an SOC is issued',
            hidden      : true,
            default     : mcpwmCount[0].name,
            options     : mcpwmCount
        },
    ]);
    
}

config = config.concat([
    {
        name : "GROUP_ET",
        displayName : "ET Trigger",
        description : "",
        longDescription : "",
        config : ET_configs
    },
    {
        name: "GROUP_ADCSOC",
        displayName: "ADC SOC Trigger",
        description: "",
        longDescription: "",
        config: ADC_SOC_configs
    }
]);


var mcpwmEventTriggerSubmodule = {
    displayName: "MCPWM Event-Trigger",
    maxInstances: Common.peripheralCount("mcpwm"),
    defaultInstanceName: "MCPWM_ET",
    description: "Enhanced Pulse Width Modulator Event Trigger",
    config: config,
    moduleInstances: (inst) => {
        if (inst.mcpwmEventTrigger_registerInterrupts)
        {
            return [{
                name: "mcpwmInt",      
                displayName: "mcpwm Interrupt ",
                moduleName: "/driverlib/interrupt.js",
                collapsed: true,
                args: {
            		$name : inst.$name + "_ET_INT",
                    int : "INT_" + inst.$name,
                    pinmuxPeripheralModule : "mcpwm",
                    driverlibInt: "INT_#"
                }
            }]
        }
        return [];
    },
    templates: {
        boardc : "", //"/gpio/gpio.board.c.xdt",
        boardh : ""//"/gpio/gpio.board.h.xdt"
    },
};

exports = mcpwmEventTriggerSubmodule;