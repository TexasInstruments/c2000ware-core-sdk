//#############################################################################
//
// FILE:   clb_ex32_led_driver.c
//
// TITLE:  CLB LED Driver Example
//
//! \addtogroup driver_example_list
//! <h1>CLB LED Drivert</h1>
//!
//! For the detailed description of this example, please refer to:
//!  How to Implement Custom Serial Interfaces Using the Configurable Logic
//!  Block (CLB) Application Note (SPRAD62).
//!
//! In this example two CLB tiles are used to communicate with an LP5891-Q1 LED
//! driver. One CCSI bus is used to transmit data using the CCSI bus protocol,
//! while a second tile is used to receive data from the CCSI bus. The C28x CPU
//! communicates with the CLB logic through a hardware-abstraction layer (HAL).
//! This example also utilizes a PWM to generate the required CCSI clocks, and
//! a timer to generate periodic sync events to the LED driver.
//!
//! This example is only available on C2000 MCU devices with CLB types 2 and up.
//!
//! \b External \b Connections \n
//!
//! CCSI Input Signal   GPIO pin    LED Driver
//! CLB_SIN_1           GPIO17      SOUT
//!
//! CCSI Output Signal  GPIO pin    LED Driver
//! CLB_SOUT_1          GPIO08      SIN
//! CLB_SCLK_1          GPIO01      SCLK
//
//#############################################################################
// $TI Release: F28003x Support Library v5.05.00.00 $
// 
// $Copyright:
// Copyright (C) 2025 Texas Instruments Incorporated - http://www.ti.com/
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
// 
//   Redistributions of source code must retain the above copyright 
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the 
//   documentation and/or other materials provided with the   
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// $
//#############################################################################

//
// Included Files
//
#include <clb_ex32_ccsi_hal.h>
#include <clb_ex32_ccsi_socket.h>
#include <clb_ex32_lp5891.h>
#include <clb_ex32_system_info.h>
#include <clb_ex32_lp589x_api.h>
#include "driverlib.h"
#include "device.h"
#include "board.h"
#include "clb_config.h"


//
// Globals
//
uint16_t cpuTimer0IntCount = 0;

//
// Function Prototypes
//
__interrupt void cpuTimer0ISR(void);
void initCPUTimer(void);
void configCPUTimer(uint32_t, float, float);

//
// Main
//
void main(void)
{
    volatile uint16_t errorDetected;
    uint16_t i;
    uint16_t fc0_0 = _FC0_0;
    uint16_t fc0_1 = _FC0_1;
    const uint16_t two_sec_cnt = ((1000000 / FRAME_PERIOD) << 1);
    uint32_t screen_color = WHITE;

    // Initialize device clock and peripherals
    Device_init();

    // Disable pin locks and enable internal pullups.
    Device_initGPIO();

    // Initialize PIE and clear PIE registers. Disables CPU interrupts.
    Interrupt_initModule();

    //
    // Initialize the PIE vector table with pointers to the shell Interrupt
    // Service Routines (ISR).
    //
    Interrupt_initVectorTable();

    // Board initialization (generated by SYSCFG tool)
    Board_init();

    // Init CLB logic
    CCSI_HAL_initClbLogic();

    // Configure and enable system interrupt
    CCSI_HAL_setupInterrupts();

    // Initialize & start LED driver clock
    CCSI_HAL_startLedClocks();

    // Register timer interrupts
    Interrupt_register(INT_TIMER0, &cpuTimer0ISR);

    // Init timer
    initCPUTimer();

    // Configure CPU timer 0 to interrupt every 1ms second
    configCPUTimer(CPUTIMER0_BASE, DEVICE_SYSCLK_FREQ, FRAME_PERIOD);

    // Enable timer interrupts
    CPUTimer_enableInterrupt(CPUTIMER0_BASE);
    Interrupt_enable(INT_TIMER0);

    // Start timer
    CPUTimer_startTimer(CPUTIMER0_BASE);

    // Enable Global Interrupt (INTM) and realtime interrupt (DBGM)
    EINT;
    ERTM;

    // Reset VSYNC
    vsyncDone = 0;

    // Clear buffers
    for(i = 0; i < MAX_DATA_LENGTH; i++)
    {
        clbXmtBuffer[i] = 0;
        clbRcvBuffer[i] = 0;
    }
    
    // Write chip index.
    LED_Set_Chip_Index(FALSE);

    // Clear number of cascaded units
    fc0_0 &= 0xFFE0;

    // Set number of cascaded units for current bus
    fc0_0 |= (CASCADED_UNITS - 1);
    
    // Clear number of scan lines
    fc0_1 &= (0xFFFF - (SCAN_NUM__MAX >> 16));

    // Set number of scan lines
    fc0_1 |= (TOTAL_SCAN_LINES - 1);

    LED_Write_Reg_Broadcast(W_FC0, _FC0_2, fc0_1, fc0_0, FALSE);
    LED_Write_Reg_Broadcast(W_FC1, _FC1_2, _FC1_1, _FC1_0, FALSE);
    LED_Write_Reg_Broadcast(W_FC2, _FC2_2, _FC2_1, _FC2_0, FALSE);
    LED_Write_Reg_Broadcast(W_FC3, _FC3_2, _FC3_1, _FC3_0, FALSE);
    LED_Write_Reg_Broadcast(W_FC4, _FC4_2, _FC4_1, _FC4_0, FALSE);
    
    // Set VSYNC
    vsyncDone = 0;

    // Send black frame to LED Driver SRAM and SYNC
    LED_Write_Black_ALL();
    sendSYNC();

    //
    // Execute your simple test here
    //
    i = 0;
    while(1) {
        // Send screen color
        switch(screen_color) {
            case (WHITE):
                LED_Write_White_ALL();
                break;
            case (RED):
                LED_Write_Red_ALL();
                break;
            case (GREEN):
                LED_Write_Green_ALL();
                break;
            case (BLUE):
                LED_Write_Blue_ALL();
                break;
            default:
                LED_Write_White_ALL();
                break;
        }

        // Send VSYNC
        sendSYNC();

        i++;
        if(i > two_sec_cnt) {
            i = 0;
            screen_color++;
            if(screen_color > BLUE) {
                screen_color = WHITE;
            }
        }
    }
}

//
// initCPUTimer - This function initializes the CPU timer 0
// to a known state.
//
void
initCPUTimer(void)
{
    //
    // Initialize timer period to maximum
    //
    CPUTimer_setPeriod(CPUTIMER0_BASE, 0xFFFFFFFF);

    //
    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT)
    //
    CPUTimer_setPreScaler(CPUTIMER0_BASE, 0);

    //
    // Make sure timer is stopped
    //
    CPUTimer_stopTimer(CPUTIMER0_BASE);

    //
    // Reload all counter register with period value
    //
    CPUTimer_reloadTimerCounter(CPUTIMER0_BASE);

    //
    // Reset interrupt counter
    //
    cpuTimer0IntCount = 0;
}

//
// configCPUTimer - This function initializes the selected timer to the
// period specified by the "freq" and "period" parameters. The "freq" is
// entered as Hz and the period in uSeconds. The timer is held in the stopped
// state after configuration.
//
void
configCPUTimer(uint32_t cpuTimer, float freq, float period)
{
    uint32_t temp;

    //
    // Initialize timer period:
    //
    temp = (uint32_t)((freq / 1000000) * period);
    CPUTimer_setPeriod(cpuTimer, temp - 1);

    //
    // Set pre-scale counter to divide by 1 (SYSCLKOUT):
    //
    CPUTimer_setPreScaler(cpuTimer, 0);

    //
    // Initializes timer control register. The timer is stopped, reloaded,
    // free run disabled, and interrupt enabled.
    // Additionally, the free and soft bits are set
    //
    CPUTimer_stopTimer(cpuTimer);
    CPUTimer_reloadTimerCounter(cpuTimer);
    CPUTimer_setEmulationMode(cpuTimer,
                              CPUTIMER_EMULATIONMODE_STOPAFTERNEXTDECREMENT);
    CPUTimer_enableInterrupt(cpuTimer);

}

//
// cpuTimer0ISR - Counter for CpuTimer0
//
__interrupt void
cpuTimer0ISR(void)
{
    cpuTimer0IntCount++;

    vsyncDone = 1;
    //
    // Acknowledge this interrupt to receive more interrupts from group 1
    //
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP1);
}

//
// End of File
//
