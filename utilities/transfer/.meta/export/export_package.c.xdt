/*
 * Copyright (c) 2020 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
 
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <export/export.h>
#include <export/export_package.h>
%
% let transferCommon;
% if (system.getProducts()[0].name.includes("C2000"))
% { transferCommon = system.getScript("/utilities/transfer/transferCommon.js");
% } else
% { transferCommon = system.getScript("/transfer/transferCommon.js");}
% 
% 
% let exportMod = system.modules[transferCommon.getTransferPath() + "exporter.js"];
% let expInst = exportMod.$instances[0];
% let comsLinkModule = expInst.comsLinkModule;
% let exportKeys = system.modules[transferCommon.getTransferPath() + "logger/keys.js"];
% let expKeyInst;
% let cLogKey;
% let txKeys = [];
% let rxKeys = [];
% if (exportKeys){
%    expKeyInst = exportKeys.$instances;
%    for(let i = 0; i < expKeyInst.length; i++){
%       if(expKeyInst[i].$name.includes("cLog")){
%           cLogKey = expKeyInst[0];
%       }
%       if(expKeyInst[i].group == "txKeyValuePairs"){
%           txKeys.push(expKeyInst[i]);
%       }
%       else if(expKeyInst[i].group == "rxKeyValuePairs"){
%           rxKeys.push(expKeyInst[i]);
%       }
%    }
% }
% console.log(expKeyInst);
% if (expInst.mode.includes("Bidirectional") && expInst["comsLinkModule"] && expInst.packageMode != "SIGNAL SIGHT")
% {
#include <libraries/jsmn/jsmn.h>
    % if (expInst.$ownedBy) {
#include <export/export_mods.h>
    % }

jsmn_parser p;                  // parses JSON data
jsmntok_t t[64];                // We expect no more than 64 tokens
% }
%
% if (expInst.exportLogBufferModule){
#include <export/export_buffer.h>
% }
%
% // let bufferDebugEnable = false;
% let terminalDebugEnable = false;
%
%if(expInst.packageMode == "JSON"){
static const char cmdTemplate[] = "{\"\":}\n";
%}
% if(expInst.packageMode == "SIGNAL SIGHT"){
% let ssMod = system.modules[transferCommon.getTransferPath() + "signalsight.js"];
% if(ssMod){
    % // bufferDebugEnable = ssMod.$instances[0].bufferingDebugModeEnable;
    % terminalDebugEnable = ssMod.$instances[0].terminalDebugModeEnable;
% }
%}

% if(expInst.packageMode != "SIGNAL SIGHT"){
static char cATXString[20];

//
// These values are used to concatenate the command and data to the command template
// when using the EXPORTPACKAGE_send functions
//
#define CMD_INDEX 1
#define DATA_INDEX 3
#define CMD_TEMPLATE_LENGTH 6
% }
% else{
void __attribute__((weak)) EXPORTPACKAGE_takeActionOnMessage(uint16_t cmdByte, uint16_t* msgData, bool error) {};
% }

%
% let charFunc = "EXPORT_transmitCharBlocking"
% let stringLengthFunc = "EXPORT_transmitStringLengthBlocking"
%
% if (expInst.exportBuffer) {
%   charFunc = "EXPORTBUFF_writeChar"
%   stringLengthFunc = "EXPORTBUFF_writeStringLength"
% }
%
%//  // Generate custom functions for each TX key type *TO DO*
%//  for(let j = 0; j < txKeys.length; j++){
%//       if(!(expKeyInst[j].$name.includes("cLog"))){  //Only generate for non-cLog functions
%//           let functype;
%//           let funcparameters;
%//           let keyType = expKeyInst[j].valType;
%//           if(keyType.includes("array")){
%//              funcparameters = keyType.replace("_array","").concat("* values");
%//              if(expKeyInst[j].lengthToggle  != "Predefine Message Length"){
%//                   funcparameters = funcparameters.concat(", uint16_t valueArrayLength");
%//              }
%//           }
%//           else {
%//              funcparameters = keyType.concat(" value");
%//           }   
%//           if(keyType.includes("8")){
%//               if(keyType.includes("array")){
%//                   keyType = "Character_array";
%//               }
%//               else{
%//                   keyType = "Character";
%//               }
%//           }
%//            int EXPORTPACKAGE_`expKeyInst[j].$name`(`funcparameters`)
%//            {
%//               let funcToCall;
%//               if(expKeyInst[j].lengthToggle  == "Predefine Message Length" && keyType.includes("array")){  //Arrays with predefined length
%//                   funcToCall = "EXPORTPACKAGE_send".concat(keyType.replace("_array","").replace("_t","").replace("u","U").replace("i","I").replace("b","B").replace("f","F")).concat("ArrayAsByteArray");
%//                    // Array length is predefined for messages with this key
%//                    uint16_t length = `expKeyInst[j].length`;
%//                    //Key from hash table
%//                    uint16_t id = `expKeyInst[j].keyValueID`;
%//                    //Transmit Frame
%//                    `funcToCall`((char*)&id, 1, values, length);
%//               }
%//               else if(!(keyType.includes("array"))){  //single values to send
%//                   funcToCall = "EXPORTPACKAGE_send".concat(keyType.replace("_array","").replace("_t","").replace("u","U").replace("i","I").replace("b","B").replace("f","F")).concat("AsByteArray");
%//                    // Array length is predefined for messages with this key
%//                    uint16_t length = `expKeyInst[j].length`;
%//                    //Key from hash table
%//                    uint16_t id = `expKeyInst[j].keyValueID`;
%//                    //Transmit frame
%//                    `funcToCall`((char*)&id, 1, value);
%//               }    
%//               else{  //Arrays with variable length
%//                   funcToCall = "EXPORTPACKAGE_send".concat(keyType.replace("_array","").replace("_t","").replace("u","U").replace("i","I").replace("b","B").replace("f","F")).concat("ArrayAsByteArray");
%//                    // Verify that passed in array length doesn't exceed max length
%//                    ASSERT(valueArrayLength <= `expKeyInst[j].lengthMax`);
%//                    //Key from hash table
%//                    uint16_t id = `expKeyInst[j].keyValueID`;
%//                    //Transmit Frame
%//                    `funcToCall`((char*)&id, 1, values, valueArrayLength);
%//               }
%//
%//                return 0;
%//            }
%//       }
%//  }
%
%
% if (expInst.packageMode == "SIGNAL SIGHT"){
//
// Defines
//
#define EP_START_BYTE 115
#define EP_END_BYTE 101

void EXPORT_receivedData(uint16_t* receivedData, uint16_t receivedDataLength){
% //if(bufferDebugEnable) {

   % //int i;
   % //for(i = 0; i < 16; i++){
   % //   EXPORTPACKAGE_rxPacketBuffer[i] = receivedData[i];
   % //}
% //}

    uint16_t cmdByte = receivedData[1];
    //
    // Check received data
    //
    if(receivedData[0] != EP_START_BYTE  || receivedData[15] != EP_END_BYTE){ //verify proper start and end byte
        //Error event
        EXPORTPACKAGE_takeActionOnMessage(cmdByte, &receivedData[2], true);
    }
    else{
        EXPORTPACKAGE_takeActionOnMessage(cmdByte, &receivedData[2], false);
    }
}
% }
%
% if (expInst.exportCustomLog) {

int EXPORTPACKAGE_sendcLog(uint32_t timestamp, char *data)
{
% if (expInst.packageMode == "START/END") {
    // Grab length of data string
    uint16_t length = strlen(data);
    // Add to length the bytes required for:
    // Key ID + timestamp 
    length = length + 1 + 4; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(`cLogKey.keyValueID`);
    // Timestamp
    `charFunc`((timestamp >> 24) & 0xFFFF);
    `charFunc`((timestamp >> 16) & 0xFFFF);
    `charFunc`((timestamp >> 8) & 0xFFFF);
    `charFunc`(timestamp & 0xFFFF);
    // String Data
    `stringLengthFunc`(data, strlen(data));
    // End byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    char val[`expInst.maxExportLength`];
    `charFunc`('{');
    `charFunc`('"');
    `stringLengthFunc`("cLog", strlen("cLog"));
    `stringLengthFunc`("\":{", strlen("\":{"));
    `stringLengthFunc`("\"ts\":", strlen("\"ts\":"));
    utoa(timestamp, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"d\":\"", strlen("\"d\":\""));
    `stringLengthFunc`(data, strlen(data));
    `charFunc`('"');

    `charFunc`('}');
    `stringLengthFunc`("}\n", strlen("}\n"));
%}

    return 0;
}

int EXPORTPACKAGE_sendcLogFloat32Array(uint32_t timestamp, float* data, uint32_t size, int numDecimal)
{
    uint32_t datai;
    char val[`expInst.maxExportLength`];
% if (expInst.packageMode == "START/END") {
    // Grab length of array
    uint16_t length = size;
    // Add to length the bytes required for:
    // Key ID + timestamp 
    length = length + 1 + 4;
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Send length
    `charFunc`(length);
    // Send key
    `charFunc`(`cLogKey.keyValueID`);
    // Send timestamp
    `charFunc`((timestamp >> 24) & 0xFFFF);
    `charFunc`((timestamp >> 16) & 0xFFFF);
    `charFunc`((timestamp >> 8) & 0xFFFF);
    `charFunc`(timestamp & 0xFFFF);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        ftoa(data[datai], val, numDecimal);
        `stringLengthFunc`(val, strlen(val));
        if (datai < (size - 1))
        {
            `charFunc`(',');
        }
    }

    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){

    `charFunc`('{');

    `charFunc`('"');
    `stringLengthFunc`("cLog", strlen("cLog"));
    `stringLengthFunc`("\":{", strlen("\":{"));

    `stringLengthFunc`("\"ts\":", strlen("\"ts\":"));
    utoa(timestamp, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"d\":\"", strlen("\"d\":\""));
    for (datai = 0; datai < size; datai++) {
        ftoa(data[datai], val, numDecimal);
        `stringLengthFunc`(val, strlen(val));
        if (datai < (size - 1))
        {
            `charFunc`(',');
        }
    }
    `charFunc`('"');

    `charFunc`('}');
    `stringLengthFunc`("}\n", strlen("}\n"));
%}
    return 0;
}

int EXPORTPACKAGE_sendcLogUint32Array(uint32_t timestamp, uint32_t* data, uint32_t size)
{
    uint32_t datai;
% if (expInst.packageMode == "START/END") {
    // Grab length of array
    uint16_t length = size;
    // Add to length the bytes required for:
    // Key ID + timestamp 
    length = length + 1 + 4;
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Send length
    `charFunc`(length);
    // Send key
    `charFunc`(`cLogKey.keyValueID`);
    // Send timestamp
    `charFunc`((timestamp >> 24) & 0xFFFF);
    `charFunc`((timestamp >> 16) & 0xFFFF);
    `charFunc`((timestamp >> 8) & 0xFFFF);
    `charFunc`(timestamp & 0xFFFF);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        utoa(data[datai], cATXString);
        `stringLengthFunc`(cATXString, strlen(cATXString));
        if (datai < (size - 1))
        {
            `charFunc`(',');
        }
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    char val[`expInst.maxExportLength`];
    `charFunc`('{');

    `charFunc`('"');
    `stringLengthFunc`("cLog", strlen("cLog"));
    `stringLengthFunc`("\":{", strlen("\":{"));

    `stringLengthFunc`("\"ts\":", strlen("\"ts\":"));
    utoa(timestamp, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"d\":\"", strlen("\"d\":\""));
    for (datai = 0; datai < size; datai++) {
        utoa(data[datai], val);
        `stringLengthFunc`(val, strlen(val));
        if (datai < (size - 1))
        {
            `charFunc`(',');
        }
    }
    `charFunc`('"');

    `charFunc`('}');
    `stringLengthFunc`("}\n", strlen("}\n"));
% }
    return 0;
}

int EXPORTPACKAGE_sendcLogInt32Array(uint32_t timestamp, int32_t* data, uint32_t size)
{
    uint32_t datai;

% if (expInst.packageMode == "START/END") {
    // Grab length of array
    uint16_t length = size;
    // Add to length the bytes required for:
    // Key ID + timestamp 
    length = length + 1 + 4;
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Send length
    `charFunc`(length);
    // Send key
    `charFunc`(`cLogKey.keyValueID`);
    // Send timestamp
    `charFunc`((timestamp >> 24) & 0xFFFF);
    `charFunc`((timestamp >> 16) & 0xFFFF);
    `charFunc`((timestamp >> 8) & 0xFFFF);
    `charFunc`(timestamp & 0xFFFF);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        itoa(data[datai], cATXString);
        `stringLengthFunc`(cATXString, strlen(cATXString));
        if (datai < (size - 1))
        {
            `charFunc`(',');
        }
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    char val[`expInst.maxExportLength`];

    `charFunc`('{');

    `charFunc`('"');
    `stringLengthFunc`("cLog", strlen("cLog"));
    `stringLengthFunc`("\":{", strlen("\":{"));

    `stringLengthFunc`("\"ts\":", strlen("\"ts\":"));
    utoa(timestamp, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"d\":\"", strlen("\"d\":\""));
    for (datai = 0; datai < size; datai++) {
        itoa(data[datai], val);
        `stringLengthFunc`(val, strlen(val));
        if (datai < (size - 1))
        {
            `charFunc`(',');
        }
    }
    `charFunc`('"');

    `charFunc`('}');
    `stringLengthFunc`("}\n", strlen("}\n"));
% }
    return 0;
}

% }
% if (expInst.$ownedBy && expInst.$ownedBy.fsilogger) {
int EXPORTPACKAGE_sendFsiFrame(uint16_t user_data, uint16_t frame_type, uint16_t frame_tag, uint16_t crc, uint16_t* words, uint16_t numWords)
{
    char val[`expInst.maxExportLength`];
    uint16_t di = 0;

    `charFunc`('{');

    `charFunc`('"');
    `stringLengthFunc`("fsiLog", strlen("fsiLog"));
    `stringLengthFunc`("\":{", strlen("\":{"));

    `stringLengthFunc`("\"u\":", strlen("\"u\":"));
    utoa(user_data, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"ty\":", strlen("\"ty\":"));
    utoa(frame_type, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"ta\":", strlen("\"ta\":"));
    utoa(frame_tag, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"c\":", strlen("\"c\":"));
    utoa(crc, val);
    `stringLengthFunc`(val, strlen(val));
    `charFunc`(',');

    `stringLengthFunc`("\"d\":\"", strlen("\"d\":\""));
    for (di = 0; di < numWords; di++) {
        utoa(words[di], val);
        `stringLengthFunc`(val, strlen(val));
        if (di+1 < numWords)
        {
            `charFunc`(',');
        }
    }
    `charFunc`('"');

    `charFunc`('}');
    `stringLengthFunc`("}\n", strlen("}\n"));
    return 0;
}
% }

% if(expInst.packageMode != "SIGNAL SIGHT"){
int EXPORTPACKAGE_sendKeyValuePointerPairs(ExportKeyValue** keyValues, uint16_t numKeyValues)
{
% if (expInst.packageMode == "START/END") {
    uint16_t keyValueI = 0;
    for (keyValueI = 0; keyValueI < numKeyValues; keyValueI++)
    {
        EXPORTPACKAGE_sendKeyValuePair(*(keyValues[keyValueI]));
    }
% } else if(expInst.packageMode == "JSON"){
    uint16_t keyValueI = 0;
    `charFunc`('{');
    for (keyValueI = 0; keyValueI < numKeyValues; keyValueI++)
    {
        `charFunc`('"');
        `stringLengthFunc`(keyValues[keyValueI]->key, keyValues[keyValueI]->lengthKey);
        `stringLengthFunc`("\":\"", strlen("\":\""));
        `stringLengthFunc`(keyValues[keyValueI]->value, keyValues[keyValueI]->lengthValue);
        `charFunc`('"');

        if (keyValueI != (numKeyValues - 1))
        {
            `charFunc`(',');
        }
    }
    `stringLengthFunc`("}\n", strlen("}\n"));
%}
    return 0;
}

int EXPORTPACKAGE_sendKeyValuePairs(ExportKeyValue* keyValues, uint16_t numKeyValues)
{
% if (expInst.packageMode == "START/END") {
    uint16_t keyValueI = 0;
    for (keyValueI = 0; keyValueI < numKeyValues; keyValueI++)
    {
        EXPORTPACKAGE_sendKeyValuePair(keyValues[keyValueI]);
    }   
% } else if(expInst.packageMode == "JSON"){
    uint16_t keyValueI = 0;
    `charFunc`('{');
    for (keyValueI = 0; keyValueI < numKeyValues; keyValueI++)
    {
        `charFunc`('"');
        `stringLengthFunc`(keyValues[keyValueI].key, keyValues[keyValueI].lengthKey);
        `stringLengthFunc`("\":\"", strlen("\":\""));
        `stringLengthFunc`(keyValues[keyValueI].value, keyValues[keyValueI].lengthValue);
        `charFunc`('"');

        if (keyValueI != (numKeyValues - 1))
        {
            `charFunc`(',');
        }
    }
    `stringLengthFunc`("}\n", strlen("}\n"));
%}
    return 0;
}

//
// To send an object with objects
// 1. Call EXPORTPACKAGE_startSendObject with the key for the top level object
// 2. Call EXPORTPACKAGE_appendKeyValuePairWithEndingChar(kv, ',') for as many sub object key/value pairs
// 2. On the last key/value EXPORTPACKAGE_appendKeyValuePairWithEndingChar(kv, '') for as many sub object key/value pairs
// 3. Call EXPORTPACKAGE_sendSendObject
//
int EXPORTPACKAGE_startSendObject(char * key)
{
% if (expInst.packageMode == "START/END") {
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Send length 0 for undefined length
    `charFunc`(0);
    // Send key
    `charFunc`(key[0]);
% } else if(expInst.packageMode == "JSON"){
    `stringLengthFunc`("{\"", strlen("{\""));
    `stringLengthFunc`(key, strlen(key));
    `stringLengthFunc`("\":{", strlen("\":{"));
%}
    return 0;
}
int EXPORTPACKAGE_endSendObject()
{
% if (expInst.packageMode == "START/END") {
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    `stringLengthFunc`("}}\n", strlen("}}\n"));
%}
    return 0;
}

int EXPORTPACKAGE_appendKeyValuePairWithEndingChar(ExportKeyValue keyValue, bool isStr, char end)
{
% if (expInst.packageMode == "START/END") {
    // Grab length of data string
    uint16_t length = keyValue.lengthValue;
    // Add to length the bytes required for Key ID
    length = 1 + length; 
    // Length
    `charFunc`(length);
    % //keyValue.lengthKey doesn't matter in this case since it should always be 1
    // Key ID
    `charFunc`(keyValue.key[0]);
    // String Data
    `stringLengthFunc`(keyValue.value, keyValue.lengthValue);
% } else if(expInst.packageMode == "JSON"){
    `charFunc`('"');
    `stringLengthFunc`(keyValue.key, keyValue.lengthKey);
    `stringLengthFunc`("\":", strlen("\":"));
    if (isStr)
    {
        `charFunc`('"');
    }
    `stringLengthFunc`(keyValue.value, keyValue.lengthValue);
    if (isStr)
    {
        `charFunc`('"');
    }
    
    if (end) {
        `charFunc`(end);
    }

%}
    return 0;
}

int EXPORTPACKAGE_sendKeyValuePair(ExportKeyValue keyValue)
{
% if (expInst.packageMode == "START/END") {
    // Grab length of data string
    uint16_t length = keyValue.lengthValue;
    // Add to length the bytes required for Key ID
    length = 1 + length;
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    % //lengthKey doesn't matter in this case since it should always be 1
    // Key ID
    `charFunc`(keyValue.key[0]);
    // String Data
    `stringLengthFunc`(keyValue.value, keyValue.lengthValue);
    // End byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`);    
    
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(keyValue.key, keyValue.lengthKey);
        } else if (i == DATA_INDEX) {
            `charFunc`('"');
            `stringLengthFunc`(keyValue.value, keyValue.lengthValue);
            `charFunc`('"');
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendString(char *cmd, uint16_t cmdLength, char *value, uint16_t valueLength)
{
% if (expInst.packageMode == "START/END") {
    uint16_t length = (UINT16_BYTE_COUNT * valueLength);
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    `charFunc`('"');
    `stringLengthFunc`(value, valueLength);
    `charFunc`('"');
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
%}else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('"');
            `stringLengthFunc`(value, strlen(value));
            `charFunc`('"');
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendInt16(char *cmd, uint16_t cmdLength, int16_t val)
{
% if (expInst.packageMode == "START/END") {
    uint16_t length = INT16_BYTE_COUNT; 
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    itoa(val, cATXString);
    `stringLengthFunc`(cATXString, strlen(cATXString));
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
%}else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            itoa(val, cATXString);
            `stringLengthFunc`(cATXString, strlen(cATXString));
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendUInt16(char *cmd, uint16_t cmdLength, uint16_t val)
{
% if (expInst.packageMode == "START/END") {
    uint16_t length = UINT16_BYTE_COUNT; 
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    utoa(val, cATXString);
    `stringLengthFunc`(cATXString, strlen(cATXString));
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
%}else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            utoa(val, cATXString);
            `stringLengthFunc`(cATXString, strlen(cATXString));
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendCharacterAsByteArray(char *cmd, uint16_t cmdLength, char val)
{
    //
    // Work in progress
    //
    return 0;
}
% } // endif not SIGNAL SIGHT mode
int EXPORTPACKAGE_sendUInt32AsByteArray(char *cmd, uint16_t cmdLength, uint32_t val)
{
    uint16_t bytes[UINT32_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = UINT32_BYTE_COUNT;
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    u32toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < UINT32_BYTE_COUNT; byteIndex++){
        `charFunc`(bytes[byteIndex]);
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];
    u32toBytes(val, bytes);
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            for (byteIndex = 0; byteIndex < UINT32_BYTE_COUNT; byteIndex++){
                utoa(bytes[byteIndex], valStr);
                `stringLengthFunc`(valStr, strlen(valStr));
                if (byteIndex < (UINT32_BYTE_COUNT - 1)){
                    `charFunc`(',');
                }
            }
            `charFunc`(']');
        }
    }
% }
% else if(expInst.packageMode == "SIGNAL SIGHT"){
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    // Key IDs
    uint16_t cmdIndex;
    for(cmdIndex = 0; cmdIndex < cmdLength; cmdIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(cmd[cmdIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(cmd[cmdIndex]);
        % }
    }
    // Send data payload
    u32toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < UINT32_BYTE_COUNT; byteIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(bytes[byteIndex]);
        % }  
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }  
    return 0;
}

int EXPORTPACKAGE_sendInt32AsByteArray(char *cmd, uint16_t cmdLength, int32_t val)
{
    uint16_t bytes[INT32_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = INT32_BYTE_COUNT;
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    i32toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < INT32_BYTE_COUNT; byteIndex++){
        `charFunc`(bytes[byteIndex]);
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 

% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];

    i32toBytes(val, bytes);
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            for (byteIndex = 0; byteIndex < INT32_BYTE_COUNT; byteIndex++){
                utoa(bytes[byteIndex], valStr);
                `stringLengthFunc`(valStr, strlen(valStr));
                if (byteIndex < (INT32_BYTE_COUNT - 1)){
                    `charFunc`(',');
                }
            }
            `charFunc`(']');
        }
    }
% }
% else if(expInst.packageMode == "SIGNAL SIGHT"){
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    // Key IDs
    uint16_t cmdIndex;
    for(cmdIndex = 0; cmdIndex < cmdLength; cmdIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(cmd[cmdIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(cmd[cmdIndex]);
        % }
    }
    // Send data payload
    i32toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < INT32_BYTE_COUNT; byteIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(bytes[byteIndex]);
        % }     
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }
    return 0;
}

int EXPORTPACKAGE_sendUInt16AsByteArray(char *cmd, uint16_t cmdLength, uint16_t val)
{
    uint16_t bytes[UINT16_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = INT16_BYTE_COUNT;
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    u16toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
        `charFunc`(bytes[byteIndex]);
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 

% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];

    u16toBytes(val, bytes);
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            for (byteIndex = 0; byteIndex < UINT16_BYTE_COUNT; byteIndex++){
                utoa(bytes[byteIndex], valStr);
                `stringLengthFunc`(valStr, strlen(valStr));
                if (byteIndex < (UINT16_BYTE_COUNT - 1)){
                    `charFunc`(',');
                }
            }
            `charFunc`(']');
        }
    }
% }
% else if(expInst.packageMode == "SIGNAL SIGHT"){
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    // Key IDs
    uint16_t cmdIndex;
    for(cmdIndex = 0; cmdIndex < cmdLength; cmdIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(cmd[cmdIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(cmd[cmdIndex]);
        % }
    }
    // Send data payload
    u16toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(bytes[byteIndex]);
        % }     
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }
    return 0;
}

int EXPORTPACKAGE_sendInt16AsByteArray(char *cmd, uint16_t cmdLength, int16_t val)
{
    uint16_t bytes[INT16_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;

% if (expInst.packageMode == "START/END") {
    uint16_t length = INT16_BYTE_COUNT;
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    i16toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
        `charFunc`(bytes[byteIndex]);
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 

% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];

    i16toBytes(val, bytes);
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
                utoa(bytes[byteIndex], valStr);
                `stringLengthFunc`(valStr, strlen(valStr));
                if (byteIndex < (INT16_BYTE_COUNT - 1)){
                    `charFunc`(',');
                }
            }
            `charFunc`(']');
        }
    }
% }
% else if(expInst.packageMode == "SIGNAL SIGHT"){
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    // Key IDs
    uint16_t cmdIndex;
    for(cmdIndex = 0; cmdIndex < cmdLength; cmdIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(cmd[cmdIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(cmd[cmdIndex]);
        % }
    }
    // Send data payload
    i16toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(bytes[byteIndex]);
        % }     
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }
    return 0;
}

int EXPORTPACKAGE_sendFloatAsByteArray(char *cmd, uint16_t cmdLength, float val)
{
    uint16_t bytes[FLOAT32_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = FLOAT32_BYTE_COUNT; 
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    f32toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < FLOAT32_BYTE_COUNT; byteIndex++){
        `charFunc`(bytes[byteIndex]);
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 

% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];

    f32toBytes(val, bytes);
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            for (byteIndex = 0; byteIndex < FLOAT32_BYTE_COUNT; byteIndex++){
                utoa(bytes[byteIndex], valStr);
                `stringLengthFunc`(valStr, strlen(valStr));
                if (byteIndex < (FLOAT32_BYTE_COUNT - 1)){
                    `charFunc`(',');
                }
            }
            `charFunc`(']');
        }
    }
% }
% else if(expInst.packageMode == "SIGNAL SIGHT"){
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    // Key IDs
    uint16_t cmdIndex;
    for(cmdIndex = 0; cmdIndex < cmdLength; cmdIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(cmd[cmdIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(cmd[cmdIndex]);
        % }
    }
    // Send data payload
    f32toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < FLOAT32_BYTE_COUNT; byteIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(bytes[byteIndex]);
        % } 
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }
    return 0;
}

int EXPORTPACKAGE_sendBoolAsByteArray(char *cmd, uint16_t cmdLength, bool val)
{
%
% if(expInst.packageMode == "SIGNAL SIGHT"){
    % // TODO: change to BOOL_BYTE_COUNT
    #define BOOL_BYTE_COUNT_TEMP 2
    uint16_t bytes[BOOL_BYTE_COUNT_TEMP] = {0};
    uint16_t byteIndex = 0;
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    // Key IDs
    uint16_t cmdIndex;
    for(cmdIndex = 0; cmdIndex < cmdLength; cmdIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(cmd[cmdIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(cmd[cmdIndex]);
        % }
    }
    // Send data payload
    u16toBytes(val, bytes);
    for (byteIndex = 0; byteIndex < BOOL_BYTE_COUNT_TEMP; byteIndex++){
        % if(terminalDebugEnable){
        EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
        % }
        % else{
        EXPORT_transmitCharBlocking(bytes[byteIndex]);
        % }    
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }
% else{
        //Work in Progress
% }
    return 0;
}
% if(expInst.packageMode != "SIGNAL SIGHT"){
int EXPORTPACKAGE_sendCharacterArrayAsByteArray(char *cmd, uint16_t cmdLength, char* data, uint32_t size)
{
    //
    // Work in progress
    //
    return 0;
}

int EXPORTPACKAGE_sendUInt32ArrayAsByteArray(char *cmd, uint16_t cmdLength, uint32_t* data, uint32_t size)
{
    uint32_t datai;
    uint16_t bytes[UINT32_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    // Total bytes being sent
    uint16_t length = (size * UINT32_BYTE_COUNT); 
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        u32toBytes(data[datai], bytes);

        for (byteIndex = 0; byteIndex < UINT32_BYTE_COUNT; byteIndex++){
            `charFunc`(bytes[byteIndex]);
        }
    }

    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            
            for (datai = 0; datai < size; datai++) {
                u32toBytes(data[datai], bytes);
                for (byteIndex = 0; byteIndex < UINT32_BYTE_COUNT; byteIndex++){
                    utoa(bytes[byteIndex], valStr);
                    `stringLengthFunc`(valStr, strlen(valStr));
                    if ((datai < (size - 1)) || (byteIndex < (UINT32_BYTE_COUNT - 1))){
                        `charFunc`(',');
                    }
                }
            }

            `charFunc`(']');
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendInt32ArrayAsByteArray(char *cmd, uint16_t cmdLength, int32_t* data, uint32_t size)
{
    uint32_t datai;
    uint16_t bytes[INT32_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = (size * INT32_BYTE_COUNT); 
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        i32toBytes(data[datai], bytes);

        for (byteIndex = 0; byteIndex < INT32_BYTE_COUNT; byteIndex++){
            `charFunc`(bytes[byteIndex]);
        }
    }

    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];

    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            
            for (datai = 0; datai < size; datai++) {
                i32toBytes(data[datai], bytes);
                for (byteIndex = 0; byteIndex < INT32_BYTE_COUNT; byteIndex++){
                    utoa(bytes[byteIndex], valStr);
                    `stringLengthFunc`(valStr, strlen(valStr));
                    if ((datai < (size - 1)) || (byteIndex < (INT32_BYTE_COUNT - 1))){
                        `charFunc`(',');
                    }
                }
            }

            `charFunc`(']');
        }
    }
%}
    return 0;
}


int EXPORTPACKAGE_sendUInt16ArrayAsByteArray(char *cmd, uint16_t cmdLength, uint16_t* data, uint32_t size)
{
    uint32_t datai;
    uint16_t bytes[UINT16_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;

% if (expInst.packageMode == "START/END") {
    uint16_t length = (size * UINT16_BYTE_COUNT);
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        u16toBytes(data[datai], bytes);

        for (byteIndex = 0; byteIndex < UINT16_BYTE_COUNT; byteIndex++){
            `charFunc`(bytes[byteIndex]);
        }
    }

    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];
    
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            
            for (datai = 0; datai < size; datai++) {
                u16toBytes(data[datai], bytes);
                for (byteIndex = 0; byteIndex < UINT16_BYTE_COUNT; byteIndex++){
                    utoa(bytes[byteIndex], valStr);
                    `stringLengthFunc`(valStr, strlen(valStr));
                    if ((datai < (size - 1)) || (byteIndex < (UINT16_BYTE_COUNT - 1))){
                        `charFunc`(',');
                    }
                }
            }

            `charFunc`(']');
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendInt16ArrayAsByteArray(char *cmd, uint16_t cmdLength, int16_t* data, uint32_t size)
{
    uint32_t datai;
    uint16_t bytes[INT16_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = (size * 2); // Size * INT16_BYTE_COUNT,
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        i16toBytes(data[datai], bytes);

        for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
            `charFunc`(bytes[byteIndex]);
        }
    }

    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    char valStr[`expInst.maxExportLength`];
    
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            
            for (datai = 0; datai < size; datai++) {
                i16toBytes(data[datai], bytes);
                for (byteIndex = 0; byteIndex < INT16_BYTE_COUNT; byteIndex++){
                    utoa(bytes[byteIndex], valStr);
                    `stringLengthFunc`(valStr, strlen(valStr));
                    if ((datai < (size - 1)) || (byteIndex < (INT16_BYTE_COUNT - 1))){
                        `charFunc`(',');
                    }
                }
            }

            `charFunc`(']');
        }
    }
%}
    return 0;
}
% } // endif !SIGNAL SIGHT

int EXPORTPACKAGE_sendFloatArrayAsByteArray(char *cmd, uint16_t cmdLength, float* data, uint32_t size)
{
    uint32_t datai;
    uint16_t bytes[FLOAT32_BYTE_COUNT] = {0};
    uint16_t byteIndex = 0;
% if (expInst.packageMode == "START/END") {
    uint16_t length = (size * FLOAT32_BYTE_COUNT);
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        f32toBytes(data[datai], bytes);

        for (byteIndex = 0; byteIndex < FLOAT32_BYTE_COUNT; byteIndex++){
            `charFunc`(bytes[byteIndex]);
        }
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    char valStr[`expInst.maxExportLength`];
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            `charFunc`('[');
            
            for (datai = 0; datai < size; datai++) {
                f32toBytes(data[datai], bytes);
                for (byteIndex = 0; byteIndex < FLOAT32_BYTE_COUNT; byteIndex++){
                    utoa(bytes[byteIndex], valStr);
                    `stringLengthFunc`(valStr, strlen(valStr));
                    if ((datai < (size - 1)) || (byteIndex < (FLOAT32_BYTE_COUNT - 1))){
                        `charFunc`(',');
                    }
                }
            }

            `charFunc`(']');
        }
    }
% } else if(expInst.packageMode == "SIGNAL SIGHT"){
    // Send start byte
    EXPORT_transmitCharBlocking(EP_START_BYTE);
    EXPORT_transmitCharBlocking(cmd[0]);
    // Send data payload
    for (datai = 0; datai < size; datai++) {
        f32toBytes(data[datai], bytes);
        for (byteIndex = 0; byteIndex < FLOAT32_BYTE_COUNT; byteIndex++){
            %if(terminalDebugEnable){
            EXPORT_transmitCharBlocking(bytes[byteIndex] + 48);
            %}
            %else{
            EXPORT_transmitCharBlocking(bytes[byteIndex]);
            %}
        }
    }
    // Send end byte
    EXPORT_transmitCharBlocking(EP_END_BYTE);
% }
    return 0;
}

%if(expInst.packageMode != "SIGNAL SIGHT"){
int EXPORTPACKAGE_sendBoolArrayAsByteArray(char *cmd, uint16_t cmdLength, bool* data, uint32_t size)
{
    //
    // Work in progress
    //  
    return 0;
}

int EXPORTPACKAGE_sendUInt32(char *cmd, uint16_t cmdLength, uint32_t val)
{
% if (expInst.packageMode == "START/END") {
    uint16_t length = UINT32_BYTE_COUNT;
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    utoa(val, cATXString);
    `stringLengthFunc`(cATXString, strlen(cATXString));
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            utoa(val, cATXString);
            `stringLengthFunc`(cATXString, strlen(cATXString));
        }
    }
%} 
    return 0;
}

int EXPORTPACKAGE_sendInt32(char *cmd, uint16_t cmdLength, int32_t val)
{
% if (expInst.packageMode == "START/END") {
    uint16_t length = INT32_BYTE_COUNT;
    // Add to length the bytes required for Key ID
    length = length + 1; 
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    itoa(val, cATXString);
    `stringLengthFunc`(cATXString, strlen(cATXString));
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            itoa(val, cATXString);
            `stringLengthFunc`(cATXString, strlen(cATXString));
        }
    }
%}
    return 0;
}

int EXPORTPACKAGE_sendBool(char *cmd, uint16_t cmdLength, bool val)
{
% if (expInst.packageMode == "START/END") {
    uint16_t length;
    if (val) {
        length = strlen("true"); 
    } 
    else {
        length = strlen("false"); 
    }
    // Add to length the bytes required for Key ID
    length = length + 1;
    // Send start byte
    `charFunc`(0x`expInst.txStartByte.toString(16).toUpperCase()`);
    // Length
    `charFunc`(length);
    // Key ID
    `charFunc`(cmd[0]);
    // Send data payload
    if (val) {
        `stringLengthFunc`("true", length);
    } 
    else {
        `stringLengthFunc`("false", length);
    }
    // Send end byte
    `charFunc`(0x`expInst.txEndByte.toString(16).toUpperCase()`); 
% } else if(expInst.packageMode == "JSON"){
    uint16_t i;
    for (i = 0; i < CMD_TEMPLATE_LENGTH; i++) {
        `charFunc`(cmdTemplate[i]);
        if (i == CMD_INDEX) {
            `stringLengthFunc`(cmd, strlen(cmd));
        } else if (i == DATA_INDEX) {
            if (val == true) {
                `stringLengthFunc`("true", strlen("true"));
            } else {
                `stringLengthFunc`("false", strlen("false"));
            }
        }
    }
%}
    return 0;
}

% if (expInst.mode.includes("Bidirectional") && expInst["comsLinkModule"])
% {
uint16_t EXPORTPACKAGE_ReadUInt16(char *string)
{
    return (uint16_t) strtoul(string, 0, 10);
}

uint32_t EXPORTPACKAGE_ReadUInt32(char *string)
{
    return (uint32_t) strtoul(string, 0, 10);
}

uint64_t EXPORTPACKAGE_ReadUInt64(char *string)
{
    return (uint64_t) strtoul(string, 0, 10);
}


int16_t EXPORTPACKAGE_ReadInt16(char *string)
{
    return (int16_t) strtol(string, 0, 10);
}

int32_t EXPORTPACKAGE_ReadInt32(char *string)
{
    return (int32_t) strtol(string, 0, 10);
}

int64_t EXPORTPACKAGE_ReadInt64(char *string)
{
    return (int64_t) strtol(string, 0, 10);
}

bool EXPORTPACKAGE_ReadBool(char *string)
{
    if (strncmp(string, "true", 4) == 0) {
        return true;
    } else {
        return false;
    }
}

float EXPORTPACKAGE_ReadFloat(char *string)
{
    return strtof(string, 0);
}

double EXPORTPACKAGE_ReadDouble(char *string)
{
    return strtod(string, 0);
}

//
// Compare JSON keys
//
// json is the JSON string.
// tok is the JSON token.
// s is the string to check for equality.
//
// return 0 if string found. -1 if not.
//
int jsoneq(const char *json, jsmntok_t *tok, const char *s)
{
    if (tok->type == JSMN_STRING && (int) strlen(s) == tok->end - tok->start &&
        strncmp(json + tok->start, s, tok->end - tok->start) == 0) {
        return 0;
    }
    return -1;
}

void EXPORTPACKAGE_parseString(char * rxString, uint16_t rxStringSize)
{
    int i;
    int r;
    % if (expInst.$ownedBy) {
    int j;
    % }

    jsmn_init(&p);

    r = jsmn_parse(
        &p, rxString, rxStringSize, t, sizeof(t) / sizeof(t[0]));

    //
    // Loop over keys of JSON object
    //
    for (i = 1; i < r; i++) {   
    % if (expInst.$ownedBy) {
        for (j = 0; j < EXPORTMOD_RXCOMMANDS_SIZE; j++) {
            if (jsoneq(rxString, &t[i], EXPORTMOD_RXCommands[j].key) == 0) {
                if (EXPORTMOD_RXCommands[j].callback != NULL) {
                    EXPORTMOD_RXCommands[j].callback(rxString + t[i + 1].start);
                }
                break;
            }
        }
    % }
    }
}
% } // Bidirectional end
% } // endif !SIGNAL SIGHT 